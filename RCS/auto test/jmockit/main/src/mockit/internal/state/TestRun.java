/*
 * Copyright (c) 2006-2014 Rog√©rio Liesenfeld
 * This file is subject to the terms of the MIT license (see LICENSE.txt).
 */
package mockit.internal.state;

import org.jetbrains.annotations.*;

import mockit.internal.mockups.*;
import mockit.internal.expectations.*;
import mockit.internal.expectations.mocking.*;

/**
 * A singleton which stores several data structures which in turn hold global state for individual test methods, test
 * classes, and for the test run as a whole.
 */
public final class TestRun
{
   private static final TestRun INSTANCE = new TestRun();
   private TestRun() {}

   // Fields with global state ////////////////////////////////////////////////////////////////////////////////////////

   private static final ThreadLocal<Integer> noMockingCount = new ThreadLocal<Integer>() {
      @Override protected Integer initialValue() { return 0; }
      @Override public void set(Integer valueToAdd) { super.set(get() + valueToAdd); }
   };

   // Used only by the Coverage tool:
   private int testId;

   @Nullable private Class<?> currentTestClass;
   @Nullable private Object currentTestInstance;
   @Nullable private SavePoint savePointForTestClass;
   @Nullable private SharedFieldTypeRedefinitions sharedFieldTypeRedefinitions;

   @NotNull private final MockFixture mockFixture = new MockFixture();

   @NotNull private final ExecutingTest executingTest = new ExecutingTest();
   @NotNull private final MockClasses mockClasses = new MockClasses();

   // Static "getters" for global state ///////////////////////////////////////////////////////////////////////////////

   public static boolean isInsideNoMockingZone() { return noMockingCount.get() > 0; }

   @Nullable public static Class<?> getCurrentTestClass() { return INSTANCE.currentTestClass; }

   @Nullable public static Object getCurrentTestInstance() { return INSTANCE.currentTestInstance; }

   @SuppressWarnings("unused")
   public static int getTestId() { return INSTANCE.testId; }

   @Nullable public static SavePoint getSavePointForTestClass() { return INSTANCE.savePointForTestClass; }

   @Nullable public static SharedFieldTypeRedefinitions getSharedFieldTypeRedefinitions()
   {
      return INSTANCE.sharedFieldTypeRedefinitions;
   }

   @NotNull public static MockFixture mockFixture() { return INSTANCE.mockFixture; }

   @NotNull public static ExecutingTest getExecutingTest() { return INSTANCE.executingTest; }

   @Nullable public static RecordAndReplayExecution getRecordAndReplayForRunningTest()
   {
      return INSTANCE.executingTest.getCurrentRecordAndReplay();
   }

   @NotNull public static RecordAndReplayExecution getOrCreateRecordAndReplayForRunningTest()
   {
      return INSTANCE.executingTest.getOrCreateRecordAndReplay();
   }

   @NotNull public static MockClasses getMockClasses() { return INSTANCE.mockClasses; }

   public static void verifyExpectationsOnAnnotatedMocks()
   {
      getMockStates().verifyExpectations();
   }

   // Static "mutators" for global state //////////////////////////////////////////////////////////////////////////////

   public static void resetExpectationsOnAnnotatedMocks()
   {
      getMockStates().resetExpectations();
   }

   public static void setCurrentTestClass(@Nullable Class<?> testClass)
   {
      INSTANCE.currentTestClass = testClass;
   }

   public static void prepareForNextTest()
   {
      INSTANCE.testId++;
      INSTANCE.executingTest.setRecordAndReplay(null);
   }

   public static void enterNoMockingZone() { noMockingCount.set(1); }
   public static void exitNoMockingZone()  { noMockingCount.set(-1); }

   public static void setRunningIndividualTest(@Nullable Object testInstance)
   {
      INSTANCE.currentTestInstance = testInstance;
   }

   public static void setSavePointForTestClass(@Nullable SavePoint savePoint)
   {
      INSTANCE.savePointForTestClass = savePoint;
   }

   public static void setSharedFieldTypeRedefinitions(@Nullable SharedFieldTypeRedefinitions redefinitions)
   {
      INSTANCE.sharedFieldTypeRedefinitions = redefinitions;
   }

   public static void finishCurrentTestExecution(boolean clearSharedMocks)
   {
      INSTANCE.executingTest.finishExecution(clearSharedMocks);
   }

   // Methods to be called only from generated bytecode or from the MockingBridge /////////////////////////////////////

   @Nullable public static Object getMock(int index)
   {
      return getMockClasses().regularMocks.getMock(index);
   }

   @SuppressWarnings("unused")
   @Nullable public static Object getStartupMock(int index)
   {
      return getMockClasses().startupMocks.getMock(index);
   }

   public static boolean updateMockState(@NotNull String mockClassDesc, int mockStateIndex)
   {
      MockStates mockStates = getMockStates();
      return mockStates.updateMockState(mockClassDesc, mockStateIndex);
   }

   @NotNull public static MockStates getMockStates()
   {
      return getMockClasses().getMockStates();
   }
}
